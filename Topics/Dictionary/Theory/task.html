<h2>Dictionary</h2>
<p>Imagine that you're a birdwatcher sitting in the park and counting birds that you see. You've observed a dozen pigeons, 5 sparrows, and even one red crossbill! Now, suppose that you want to store these observations for later use. You need to remember exactly how many birds of each kind you've seen. So, a simple list with numbers won't do because you won't be able to tell which number refers to which bird. You need a data type that can associate one thing with another: in our case, the name of the bird with the number of observations.</p>
<p>Luckily, Python has such a type — <strong>dictionary</strong> (<code class="language-python">dict</code>). You can picture a real dictionary — a large book with definitions for a lot of words. The definition contains two parts: the word itself (let's call it a <strong>key</strong>) and the definition for it (a <strong>value</strong>). In our birdwatcher example, the keys are names of the birds ("pigeon", "sparrow", and "red crossbill") and the values are how many birds of that kind we've seen (12, 5 and 1, respectively).</p>
<p>In programming, dictionaries work in a similar way: if we want to store an object, we need to select some key for it and put our object as a value for that key into our dictionary.</p>
<h5 id="dictionary-creation">Dictionary creation</h5>
<p>A dictionary consists of a collection of key-value pairs. Each key-value pair maps the key to its associated value. If you already know the values needed, then the easiest way to create a dictionary is to use the <strong>curly braces</strong> with a comma-separated list of <code class="language-python">key: value</code> pairs. If you want to create an empty dictionary, you can do so with the help of curly braces as well. Note that values in a dictionary can be of <strong>different types</strong>.</p>
<pre><code class="language-python">birds = {"pigeon": 12, "sparrow": 5, "red crossbill": 1}
prices = {'espresso': 5.0, 'americano': 8.0, 'latte': 10, 'pastry': 'various prices'}
empty_dict = {}

print(type(birds))  # &lt;class 'dict'&gt;
print(type(prices))  # &lt;class 'dict'&gt;
print(type(empty_dict))  # &lt;class 'dict'&gt;</code></pre>
<p>Another way to create a dictionary is to use the <code class="language-python">dict</code> constructor.</p>
<pre><code class="language-python">another_empty_dict = dict()  # using the dict constructor

print(type(another_empty_dict))  # &lt;class 'dict'&gt;</code></pre>
<p>When creating a non-empty dictionary, a dict constructor can take a dictionary as an argument, and / or future dictionary keys as arguments with assigned values, as in the example:</p>
<pre><code class="language-python"># note that the future dictionary keys are listed without quotes
prices_with_constr = dict({'espresso': 5.0}, americano=8.0, latte=10, pastry='various prices')

print(prices_with_constr)  # {'espresso': 5.0, 'americano': 8.0, 'latte': 10, 'pastry': 'various prices'}</code></pre>
<p>When we give the dict constructor dictionary keys with assigned values, as <code class="language-python">dict(americano=8.0)</code>, the left part of the expression is treated as a variable. In contrast to the use of curly braces, in which you can use integers as keys, keys in the dict constructor can't be an integer, a string in quotes, a list, a multiword expression, etc. That is, the following lines will give you an error:</p>
<pre><code class="language-python">d1 = dict(888=8.0)
d2 = dict("americano"=8.0)
d3 = dict(["americano", "filter"]=8.0)
d4 = dict(the best americano=8.0)</code></pre>
<p> </p>
<p>Overall, the curly braces and the dict constructor are interchangeable, just mind the feature given above.</p>
<p> </p>
<p>Finally, you can create a nested dictionary. It's a collection of dictionaries inside one single dictionary.</p>
<pre><code class="language-python"># a nested dictionary example
my_pets = {'dog': {'name': 'Dolly', 'breed': 'collie'},
           'cat': {'name': 'Fluffy', 'breed': 'maine coon'}}

# another nested dictionary example
# note that keys of the outer dictionary are numbers
digits = {1: {'Word': 'one', 'Roman': 'I'}, 
          2: {'Word': 'two', 'Roman': 'II'}, 
          3: {'Word': 'three', 'Roman': 'III'}, 
          4: {'Word': 'four', 'Roman': 'IV'}, 
          5: {'Word': 'five', 'Roman': 'V'}}</code></pre>
<h5 id="accessing-the-items">Accessing the items</h5>
<p>The syntax for <strong>accessing</strong> an item is quite simple — dictionary name followed by a key in square brackets <code class="language-python">[]</code>. This approach works both for adding objects to a dictionary and for reading them from there:</p>
<pre><code class="language-python">my_pet = {}

# add 3 keys and their values into the dictionary
my_pet['name'] = 'Dolly'
my_pet['animal'] = 'dog'
my_pet['breed'] = 'collie'

print(my_pet)  # {'name': 'Dolly', 'animal': 'dog', 'breed': 'collie'}

# get information from the dictionary about an added item
print(my_pet['name'])  # Dolly</code></pre>
<p>When working with a nested dictionary, getting the right value may be a little harder. As in our example, there are different levels and you need to stop at the right depth.</p>
<pre><code class="language-python"># our nested dictionary once again:
my_pets = {'dog': {'name': 'Dolly', 'breed': 'collie'},
           'cat': {'name': 'Fluffy', 'breed': 'maine coon'}}

print(my_pets['cat'])  # {'name': 'Fluffy', 'breed': 'maine coon'}

print(my_pets['cat']['breed'])  # maine coon</code></pre>
<h5 id="choosing-the-keys">Choosing the keys</h5>
<p>You can save objects of any type in a dictionary, but not all of them qualify as a key. You need a good, <strong>unique</strong> key for each object in your collection. Still, this is not the only restriction on dictionary keys and we will cover them later. For now, safely use numbers and strings.</p>
<p>If a key has already been added to your dictionary, its old value will be overwritten:</p>
<pre><code class="language-python">trilogy = {'IV': 'Star Wars', 'V': 'The Empire Strikes Back', 'VI': 'Return of the Jedi'}
print(trilogy['IV'])  # Star Wars

trilogy['IV'] = 'A New Hope'
print(trilogy['IV'])  # A New Hope</code></pre>
<p>In <strong>Python 3.7 and up</strong>, dictionaries do maintain the <strong>insertion order</strong> for values they store, but in previous versions it is not necessarily so:</p>
<pre><code class="language-python">alphabet = {}
alphabet['alpha'] = 1
alphabet['beta'] = 2

print(alphabet)
# Python 3.8 output: {'alpha': 1, 'beta': 2}</code></pre>
<h5 id="conclusion">Conclusion</h5>
<p>In this topic we've covered some basics for the <strong>dictionary </strong>data type in Python:</p>
<ul>
<li>how to create a dictionary,</li>
<li>what is a nested dictionary,</li>
<li>how to manage dictionary items: keys and values.</li>
</ul>
<p>In the following lesson you'll get acquainted with basic operations on dictionaries, but first, let's practice some tasks, so you would feel confident using this data type!</p>
