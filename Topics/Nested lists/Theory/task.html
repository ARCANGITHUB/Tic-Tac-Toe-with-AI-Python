<h2>Nested lists</h2>
<p>A list in Python may contain any objects as its elements, including other lists – they are called <strong>nested lists</strong>. Here are some examples of nested lists:</p>
<pre><code class="language-python">nested_letters  = ['a', 'b', ['c', 'd'], 'e']
nested_numbers = [[1], [2], [3]]
</code></pre>
<h5 id="accessing-elements-of-nested-lists">Accessing elements of nested lists</h5>
<p>Like with regular lists, elements of a nested list can be accessed by indexes. Note that the nested list still counts as a single element in its parent list.</p>
<pre><code class="language-python">numbers = [1, [2, 3], 4]
nested_numbers = numbers[1]

print(nested_numbers)     # [2, 3]
print(nested_numbers[1])  # 3
</code></pre>
<p>In this example, we obtain the second element of <code class="language-python">numbers</code> by index 1. This element is the nested list <code class="language-python">[2, 3]</code>. Then we print the second element of <code class="language-python">nested_numbers</code> by index 1. This element is 3.</p>
<p>It is also possible to access an element of a nested list without an additional variable using a sequence of square brackets.</p>
<pre><code class="language-python">lists = [0, [1, [2, 3]]]
print(lists[1][1][0])   # 2</code></pre>
<p>Basically, we go deeper from the outer list to the innermost when indexing. Naturally, if we ask for an element at the level that doesn't exist, we'll get an error:</p>
<pre><code class="language-python">print(lists[1][1][0][1])  # TypeError: 'int' object is not subscriptable</code></pre>
<p>Just like when we try accessing an element that doesn't exist at the level that does exist:</p>
<pre><code class="language-python">print(lists[3])  # IndexError: list index out of range</code></pre>
<h5 id="matrices">Matrices</h5>
<p>Nested lists are a convenient way to represent a matrix. For example, the matrix</p>
<p style="text-align: center;"><img alt="simple matrix" height="77" src="https://ucarecdn.com/46c9c04d-fe77-4a2c-a8d5-b54c39d62b7d/-/crop/80x77/20,0/-/preview/" width="80"/></p>
<p>might be represented as:</p>
<pre><code class="language-python">M = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</code></pre>
<p>Note that in such a list lengths of all nested lists must be the same, and they are equal to the dimension of the matrix.</p>
<p>When we want to extract an element from the matrix, e.g. element <em>M[1][2] = 6</em>, the first index selects the row, and the second index selects the column. However, as you know, it differs from mathematical representation in that numbering here starts from zero, rather than from one.</p>
<h5 id="nested-list-comprehension">Nested list comprehension</h5>
<p>To iterate over nested lists, we can use <strong>nested list comprehensions</strong>. It is basically a combination of two or more list comprehensions and it is quite similar to nested "for" loops. To illustrate basic syntax for this kind of comprehension, let's consider an example.</p>
<p>Imagine a school as a list of classes and the classes are lists of student names.</p>
<pre><code class="language-python"># original list
school = [["Mary", "Jack", "Tiffany"], 
          ["Brad", "Claire"],
          ["Molly", "Andy", "Carla"]]</code></pre>
<p>If you want to create a list of all students in all classes without the list comprehension it would look like this:</p>
<pre><code class="language-python">student_list = []
for class_group in school:
    for student in class_group:
        student_list.append(student)</code></pre>
<p>Alternatively, we can also use a comprehension with a double <code class="language-python">for</code> loop, then it would look like this:</p>
<pre><code class="language-python">student_list = [student for class_group in school for student in class_group]</code></pre>
<p>In both cases the result is going to be the same:</p>
<pre><code class="language-python">print(student_list)
# result: ["Mary", "Jack", "Tiffany", "Brad", "Claire", "Molly", "Andy", "Carla"]
</code></pre>
<p>In this case, the order of the <code class="language-python">for</code> loops is the same as in the notation with indentation: first the outer loop, and then the inner loop.</p>
<p></p><div class="alert alert-primary">However, such a method may be less clear than the one without list comprehension, especially in cases when we need to use more than two <code class="language-python">for</code> loops: it can make the code unreadable and counter-intuitive.</div><p></p>
<p>Consider the following line of code:</p>
<pre><code class="language-python">matrix = [[j for j in range(5)] for i in range(2)]</code></pre>
<p>It’s not that easy to understand what the created matrix will look like. Compare to when we will put it this way:</p>
<pre><code class="language-python">matrix = [] 
  
for i in range(2): 
      
    # create empty row (a sublist inside our list)
    matrix.append([]) 
      
    for j in range(5): 
        matrix[i].append(j) 
</code></pre>
<p>It is much more readable, and now it is clear that the matrix will look like:</p>
<pre><code class="language-python">matrix = [[0, 1, 2, 3, 4],
          [0, 1, 2, 3, 4]]</code></pre>
<p>It's important to bear in mind that shorter code does not imply better one, so you shouldn’t misuse list comprehension when working with nested lists.</p>
<h5 id="summary">Summary</h5>
<p>To sum up, lists as such are a very useful type of container in Data Structures, and now you know how to store multiple inner lists inside an outer one, reach them, represent matrices with them, and use nested list comprehensions.</p>
